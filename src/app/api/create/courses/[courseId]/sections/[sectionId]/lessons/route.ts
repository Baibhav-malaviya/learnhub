import { NextResponse } from "next/server";
import mongoose from "mongoose";
import Course, { ICourse, ILesson } from "@/model/course.model";
import connectDB from "@/lib/connectDB";
import cloudinary from "@/app/utils/cloudinary.config";
import { writeFile } from "fs/promises";
import { join } from "path";
import os from "os";

export async function POST(
	request: Request,
	{ params }: { params: { courseId: string; sectionId: string } }
) {
	try {
		connectDB();
		const { courseId, sectionId } = params;

		// Parse formData
		const formData = await request.formData();
		const file = formData.get("file") as File;
		const title = formData.get("title") as string;
		const content = formData.get("content") as string;
		const isForPreview = formData.get("isForPreview") === "true"; // Convert to boolean
		const fileSize = formData.get("fileSize") as string;

		// Validate IDs
		if (
			!mongoose.Types.ObjectId.isValid(courseId) ||
			!mongoose.Types.ObjectId.isValid(sectionId)
		) {
			return NextResponse.json(
				{ error: "Invalid course ID or section ID" },
				{ status: 400 }
			);
		}

		// Check if required fields are present
		if (!file || !title || !content) {
			return NextResponse.json(
				{
					success: false,
					message: `Missing required data`,
				},
				{ status: 400 }
			);
		}

		// Save file temporarily
		const bytes = await file.arrayBuffer();
		const buffer = Buffer.from(bytes);
		const tempDir = os.tmpdir();
		const path = join(tempDir, file.name);
		await writeFile(path, buffer);

		// Upload to Cloudinary
		const uploadResponse = await new Promise((resolve, reject) => {
			cloudinary.uploader.upload(
				path,
				{
					resource_type: "video",
					folder: "learnhub/lessons",
					quality: "auto",
					fetch_format: "auto",
					width: 720,
					height: 480, // Added height parameter
					crop: "fill", // Changed from "scale" to "fill"
					gravity: "center", // Added to ensure centering of the video
					video_codec: "auto",
					chunk_size: 10000000, // 10MB chunks
				},
				(error, result) => {
					if (error) reject(error);
					else resolve(result);
				}
			);
		});

		// Cast uploadResponse to any to avoid TypeScript errors
		const cloudinaryResponse = uploadResponse as any;

		// Generate URLs
		const videoUrl = cloudinary.url(cloudinaryResponse.public_id, {
			resource_type: "video",
			streaming_profile: "hd",
			format: "m3u8",
		});

		// Create the lesson object
		const newLesson: ILesson = {
			_id: new mongoose.Types.ObjectId(), // Automatically generate a new ObjectId
			title,
			content,
			videoUrl, // Use the URL generated by Cloudinary
			duration: +(cloudinaryResponse.duration / 60).toFixed(2), // Convert seconds to minutes
			preview: isForPreview,
		};

		// Update the course document
		const course = (await Course.findOneAndUpdate(
			{ _id: courseId, "sections._id": sectionId },
			{ $push: { "sections.$.lessons": newLesson } },
			{ new: true }
		)) as ICourse | null;

		if (!course) {
			return NextResponse.json(
				{ error: "Course or section not found" },
				{ status: 404 }
			);
		}

		// Return success response
		return NextResponse.json(
			{ message: "Lesson added successfully", lesson: newLesson },
			{ status: 201 }
		);
	} catch (error) {
		console.error("Error adding lesson:", error);
		return NextResponse.json(
			{ error: "Failed to add lesson" },
			{ status: 500 }
		);
	}
}
